<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Templist Parser WebUI</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <style>
        :root {
            --md-primary: #FF8F00; --md-on-primary: #1E1E1E; --md-primary-container: #FFB74D;
            --md-on-primary-container: #1E1E1E; --md-secondary: #FFCC80; --md-on-secondary: #1E1E1E;
            --md-surface: #1E1E1E; --md-on-surface: #FFFFFF; --md-surface-variant: #2D2D2D;
            --md-on-surface-variant: #CCCCCC; --md-outline: #4A4A4A; --md-error: #F44336;
            --md-warning: #FFC107; --md-background: #121212; --md-shape-corner: 12px;
            --spacing-unit: 8px; --line-number-width: 40px; --textarea-highlight-color: rgba(255, 143, 0, 0.1);
        }

        *, :after, :before { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--md-background); color: var(--md-on-surface);
            line-height: 1.6; padding: calc(var(--spacing-unit) * 2); min-height: 100vh; transition: background-color 0.3s;
        }
        body.fullscreen-active { overflow: hidden; }

        .container { max-width: 1200px; margin: 0 auto; }
        header { text-align: center; padding: calc(var(--spacing-unit) * 2) 0 calc(var(--spacing-unit) * 3); }
        h1 { font-size: 2.2rem; font-weight: 700; color: var(--md-primary); margin-bottom: var(--spacing-unit); }
        h2 { font-size: 1.5rem; font-weight: 500; color: var(--md-primary); }
        .subtitle, .github-link { font-size: 1.1rem; color: var(--md-secondary); max-width: 700px; margin: 0 auto var(--spacing-unit); }
        .github-link { font-size: 0.9rem; color: var(--md-primary-container); text-decoration: none; display: inline-flex; align-items: center; gap: 4px; }
        .github-link:hover { text-decoration: underline; color: var(--md-primary); }

        .card {
            background-color: var(--md-surface); border-radius: var(--md-shape-corner);
            padding: calc(var(--spacing-unit) * 2.5); margin-bottom: calc(var(--spacing-unit) * 2.5);
        }
        .card-header {
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
            margin-bottom: calc(var(--spacing-unit) * 2); padding-bottom: calc(var(--spacing-unit) * 1.5);
            border-bottom: 1px solid var(--md-outline); gap: calc(var(--spacing-unit) * 1.5);
        }
        .card-header h2 { width: 100%; }

        .btn-group { display: flex; gap: calc(var(--spacing-unit) * 1.5); flex-wrap: wrap; width: 100%; }
        .btn, .template-btn {
            display: inline-flex; align-items: center; justify-content: center; gap: var(--spacing-unit);
            border-radius: 20px; border: none; font-size: 0.875rem; font-weight: 500; cursor: pointer;
            transition: background-color 0.2s, transform 0.2s, color 0.2s, opacity 0.3s;
        }
        .btn {
            padding: calc(var(--spacing-unit) * 1.25) calc(var(--spacing-unit) * 2.5);
            background-color: var(--md-primary); color: var(--md-on-primary);
            flex: 1 1 auto; min-width: 120px; text-align: center;
        }
        .btn:hover { background-color: #E65100; }
        .btn:active { transform: translateY(1px); }
        .btn-outline { background-color: transparent; border: 1px solid var(--md-outline); color: var(--md-primary); }
        .btn-outline:hover { background-color: rgba(255, 143, 0, 0.1); }
        .btn-icon { padding: var(--spacing-unit); border-radius: 50%; min-width: 40px; min-height: 40px; flex: 0 0 auto; }

        .template-selector {
            display: flex; flex-wrap: wrap; gap: calc(var(--spacing-unit) * 1.5);
            margin-bottom: calc(var(--spacing-unit) * 2); justify-content: center;
        }
        .template-btn {
            flex: 1 1 120px; min-width: 120px; text-align: center; padding: calc(var(--spacing-unit) * 1.5);
            background-color: var(--md-surface-variant); border-radius: 8px;
        }
        .template-btn:hover, .btn:hover { background-color: #3A3A3A; }
        .template-btn.active { background-color: var(--md-primary-container); color: var(--md-on-primary-container); font-weight: 500; }

        .editor-container {
            display: flex; position: relative; border: 1px solid var(--md-outline);
            border-radius: 8px; overflow: hidden;
        }
        .editor-container:focus-within { border-color: var(--md-primary); }

        .line-numbers {
            width: var(--line-number-width); padding: calc(var(--spacing-unit) * 2) 0; flex-shrink: 0;
            background-color: var(--md-surface-variant); color: var(--md-on-surface-variant);
            text-align: right; font-family: 'Roboto Mono', monospace; font-size: 14px; line-height: 1.5;
            user-select: none; overflow: hidden; border-right: 1px solid var(--md-outline);
        }
        .line-numbers div {
            padding-right: var(--spacing-unit); white-space: nowrap; transition: background-color 0.3s;
            height: calc(14px * 1.5);
        }
        .line-numbers div.highlighted { background-color: rgba(255, 143, 0, 0.2); color: var(--md-primary); }

        .input-area-wrapper { position: relative; flex-grow: 1; display: flex; }
        textarea {
            width: 100%; min-height: 300px; padding: calc(var(--spacing-unit) * 2); flex-grow: 1;
            border: none; border-radius: 0; font-family: 'Roboto Mono', monospace; font-size: 14px;
            line-height: 1.5; resize: vertical; background-color: var(--md-surface-variant);
            color: var(--md-on-surface); display: block; overflow-y: scroll; background-image: none;
            background-repeat: no-repeat; background-size: 100% calc(14px * 1.5); transition: background-image 0.3s;
        }
        textarea:focus { outline: none; }
        .output-container textarea { background-color: #2D2D2D; }

        .textarea-controls {
            position: absolute; top: calc(var(--spacing-unit) * 1.5); right: calc(var(--spacing-unit) * 1.5); z-index: 10;
        }
        .editor-container.fullscreen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1000;
            background-color: var(--md-background); padding: calc(var(--spacing-unit) * 2); border: none;
            border-radius: 0; flex-direction: row;
        }
        .editor-container.fullscreen .line-numbers,
        .editor-container.fullscreen .input-area-wrapper { height: 100%; }
        .editor-container.fullscreen #inputText { height: 100%; min-height: 0; }
        .editor-container.fullscreen ~ * { display: none !important; }
        .editor-container.fullscreen .textarea-controls {
            top: calc(var(--spacing-unit) * 2); right: calc(var(--spacing-unit) * 2);
        }
        .editor-container.fullscreen .textarea-controls .btn-icon {
            background-color: rgba(0,0,0,0.5); color: white;
        }
        .editor-container.fullscreen .textarea-controls .btn-icon:hover { background-color: rgba(0,0,0,0.7); }

        #lintMessages {
            margin-top: calc(var(--spacing-unit) * 1.5); padding: var(--spacing-unit); max-height: 150px;
            overflow-y: auto; background-color: var(--md-surface-variant); border-radius: 8px; font-size: 0.875rem;
        }
        #lintMessages ul { list-style: none; padding: 0; margin: 0; }
        #lintMessages li {
            padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit); display: flex;
            align-items: center; gap: var(--spacing-unit); cursor: pointer; border-bottom: 1px solid var(--md-outline);
        }
        #lintMessages li:last-child { border-bottom: none; }
        #lintMessages li:hover { background-color: rgba(255,255,255,0.05); }
        .lint-error { color: var(--md-error); }
        .lint-warning { color: var(--md-warning); }
        .lint-icon { font-size: 1.2rem; }

        .output-container { position: relative; }
        .copy-btn { position: absolute; top: calc(var(--spacing-unit) * 2); right: calc(var(--spacing-unit) * 2); z-index: 10; }
        .mobile-copy-btn { display: none; width: 100%; margin-top: calc(var(--spacing-unit) * 1.5); }

        .features {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: calc(var(--spacing-unit) * 2); margin-bottom: calc(var(--spacing-unit) * 2);
        }
        .feature-card {
            background-color: var(--md-surface-variant); border-radius: var(--md-shape-corner);
            padding: calc(var(--spacing-unit) * 2);
        }
        .feature-card h4 {
            display: flex; align-items: center; gap: var(--spacing-unit);
            font-size: 1.1rem; margin-bottom: var(--spacing-unit); color: var(--md-secondary);
        }
        .feature-card p { color: var(--md-on-surface-variant); }

        .comment-toggle {
            display: flex; align-items: center; gap: var(--spacing-unit);
            margin: calc(var(--spacing-unit) * 1.5) 0 calc(var(--spacing-unit) * 0.5); justify-content: flex-start;
        }
        .switch { position: relative; display: inline-block; width: 42px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #666; transition: .4s; border-radius: 24px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--md-primary); }
        input:checked + .slider:before { transform: translateX(18px); }

        #scrollToTopBtn {
            display: none; position: fixed; bottom: calc(var(--spacing-unit) * 3);
            right: calc(var(--spacing-unit) * 3); z-index: 999; opacity: 0.8;
        }
        #scrollToTopBtn:hover { opacity: 1; }

        @media (max-width: 768px) {
            h1 { font-size: 1.8rem; } h2 { font-size: 1.3rem; }
            .card-header { flex-direction: column; align-items: center; }
            .card-header h2 { text-align: center; margin-bottom: var(--spacing-unit); }
            .btn-group { justify-content: center; }
            .btn-group .btn { flex-grow: 1; min-width: calc(50% - var(--spacing-unit) * 0.75); }
            .copy-btn { display: none !important; }
            .mobile-copy-btn { display: flex !important; }
            .output-container textarea { padding-right: calc(var(--spacing-unit) * 2); }
            .textarea-controls { top: var(--spacing-unit); right: var(--spacing-unit); }
            .line-numbers { display: none; }
            .editor-container, textarea { border-radius: 8px; }
            .editor-container.fullscreen .line-numbers { display: flex; flex-direction: column; }
            #scrollToTopBtn { bottom: calc(var(--spacing-unit) * 2); right: calc(var(--spacing-unit) * 2); }
            .stash-controls { flex-direction: column; align-items: stretch; }
            .stash-controls > div, .stash-controls > button { width: 100%; margin-bottom: var(--spacing-unit); }
            .stash-controls > div { justify-content: space-between; }
        }
        @media (max-width: 480px) {
            body { padding: var(--spacing-unit); }
            .card { padding: calc(var(--spacing-unit) * 1.5); }
            .template-selector, .btn-group { gap: var(--spacing-unit); }
            .template-btn { flex-basis: calc(50% - var(--spacing-unit) * 0.5); min-width: calc(50% - var(--spacing-unit) * 0.5); padding: var(--spacing-unit); }
            .btn-group .btn { min-width: 100%; flex-basis: 100%; }
            .btn { padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5); font-size: 0.8rem; }
            .btn .material-icons, .mobile-copy-btn .material-icons { font-size: 1.1rem; }
        }
        @media (min-width: 769px) {
            .output-container textarea { padding-right: calc(var(--spacing-unit) * 7.5); }
        }
    </style>
</head>
<body>
    <div class="container" id="mainContainer">
        <header>
            <h1>Templist Parser WebUI</h1>
            <p class="subtitle">Build waifu from template, parse into inline PList</p>
            <a href="https://github.com/PopCat19/templist-parser-webui" target="_blank" rel="noopener noreferrer" class="github-link">
                <i class="material-icons" style="vertical-align: middle; font-size: 1.2em;">code</i> View on GitHub
            </a>
        </header>

        <div class="card">
            <div class="card-header"><h2>Template Selection</h2>
                <div class="btn-group">
                    <button class="btn" id="convertBtn"><i class="material-icons">swap_horiz</i> Convert to PList</button>
                    <button class="btn btn-outline" id="formatPListBtn"><i class="material-icons">notes</i> Format PList</button>
                    <button class="btn btn-outline" id="clearBtn"><i class="material-icons">clear</i> Clear</button>
                </div>
            </div>
            <div class="template-selector">
                <div class="template-btn active" data-template="empty">Empty Template</div>
                <div class="template-btn" data-template="hina">Sorasaki Hina</div>
                <div class="template-btn" data-template="minimal">Minimal Template</div>
                <div class="template-btn" data-template="fantasy">Fantasy Character</div>
            </div>

            <div class="stash-controls" style="display: flex; flex-wrap: wrap; gap: calc(var(--spacing-unit) * 1.5); align-items: center; margin-bottom: calc(var(--spacing-unit) * 2); justify-content: space-around; padding: var(--spacing-unit) 0; border-top: 1px solid var(--md-outline); border-bottom: 1px solid var(--md-outline); margin-top: var(--spacing-unit);">
                <div class="comment-toggle" style="margin: 0;">
                    <label class="switch">
                        <input type="checkbox" id="autoStashToggle">
                        <span class="slider"></span>
                    </label>
                    <span style="font-size: 0.875rem;">Auto-Save Draft</span>
                </div>
                <button class="btn btn-outline" id="manualStashBtn" style="flex-grow: 0; min-width: auto; padding: calc(var(--spacing-unit)*0.8) calc(var(--spacing-unit)*1.5);"><i class="material-icons">save</i> Save Draft</button>
                <button class="btn btn-outline" id="loadStashBtn" style="flex-grow: 0; min-width: auto; padding: calc(var(--spacing-unit)*0.8) calc(var(--spacing-unit)*1.5);"><i class="material-icons">restore</i> Load Draft</button>
                <button class="btn btn-outline btn-icon" id="clearStashBtn" title="Clear Saved Draft" style="flex-grow: 0; border-color: var(--md-warning); color: var(--md-warning); min-width: auto; padding: calc(var(--spacing-unit)*0.8);"><i class="material-icons">delete_sweep</i></button>
            </div>

            <div class="comment-toggle">
                <label class="switch"><input type="checkbox" id="removeComments" checked><span class="slider"></span></label>
                <span>Remove comments during conversion</span>
            </div>
            
            <div class="editor-container" id="editorContainer">
                <div class="line-numbers" id="lineNumbers"></div>
                <div class="input-area-wrapper" id="inputAreaWrapper">
                    <div class="textarea-controls">
                        <button class="btn btn-icon" id="fullscreenBtn" title="Toggle Fullscreen">
                            <i class="material-icons" id="fullscreenIcon">fullscreen</i>
                        </button>
                    </div>
                    <textarea id="inputText" placeholder="Select a template or start editing..." spellcheck="false"></textarea>
                </div>
            </div>
            <div id="lintMessages"><ul></ul></div>
        </div>

        <div class="card output-container" id="outputCard">
            <div class="card-header"><h2>PList Output</h2></div>
            <textarea id="outputText" readonly placeholder="Your converted PList will appear here..."></textarea>
            <button class="btn btn-icon copy-btn" id="copyBtn" title="Copy to clipboard"><i class="material-icons">content_copy</i></button>
            <button class="btn mobile-copy-btn" id="mobileCopyBtn"><i class="material-icons">content_copy</i> Copy to Clipboard</button>
        </div>

        <div class="card">
            <h2>Features</h2>
            <div class="features">
                <div class="feature-card"><h4><i class="material-icons">dashboard</i> Template Selection</h4><p>Choose pre-built templates. Switch anytime.</p></div>
                <div class="feature-card"><h4><i class="material-icons">comment</i> Comment Support</h4><p>Use // or #. Toggle removal on conversion.</p></div>
                <div class="feature-card"><h4><i class="material-icons">code</i> PList Conversion</h4><p>Convert to single-line PList format.</p></div>
                <div class="feature-card"><h4><i class="material-icons">fullscreen</i> Fullscreen Edit</h4><p>Toggle fullscreen mode for focused editing.</p></div>
                <div class="feature-card"><h4><i class="material-icons">rule</i> Syntax Hints</h4><p>Basic syntax checks for your template.</p></div>
                <div class="feature-card"><h4><i class="material-icons">format_list_numbered</i> Line Numbers</h4><p>Line numbers for easier error tracking.</p></div>
            </div>
        </div>
    </div>

    <button class="btn btn-icon" id="scrollToTopBtn" title="Scroll to Top">
        <i class="material-icons">arrow_upward</i>
    </button>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Map template keys to their file paths
            const templateFiles = {
                empty: './templates/empty.md',
                hina: './templates/hina.md',
                minimal: './templates/minimal.md',
                fantasy: './templates/fantasy.md'
            };

            const inputText = document.getElementById('inputText');
            const outputText = document.getElementById('outputText');
            const convertBtn = document.getElementById('convertBtn');
            const formatPListBtn = document.getElementById('formatPListBtn');
            const copyBtn = document.getElementById('copyBtn');
            const mobileCopyBtn = document.getElementById('mobileCopyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const templateBtns = document.querySelectorAll('.template-btn');
            const removeCommentsCheckbox = document.getElementById('removeComments');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const fullscreenIcon = document.getElementById('fullscreenIcon');
            const editorContainer = document.getElementById('editorContainer');
            const mainContainer = document.getElementById('mainContainer');
            const lintMessagesUl = document.querySelector('#lintMessages ul');
            const lineNumbersDiv = document.getElementById('lineNumbers');
            const outputCard = document.getElementById('outputCard');
            const scrollToTopBtn = document.getElementById('scrollToTopBtn');

            // Stash Controls
            const autoStashToggle = document.getElementById('autoStashToggle');
            const manualStashBtn = document.getElementById('manualStashBtn');
            const loadStashBtn = document.getElementById('loadStashBtn');
            const clearStashBtn = document.getElementById('clearStashBtn');

            const STASH_KEY = 'templistParserInputStash';
            const AUTO_STASH_ENABLED_KEY = 'templistParserAutoStashEnabled';

            let isDirty = false;
            let stashTimeout = null;
            const STASH_DEBOUNCE_TIME = 2000; // 2 seconds

            const originalConvertBtnHTML = convertBtn.innerHTML;
            let convertClickCount = 0;
            let convertClickTimer = null;
            const DOUBLE_CLICK_TIMEOUT = 2000;

            // --- Dirty Flag and Stash Logic ---
            function markDirty(makeDirty = true) {
                isDirty = makeDirty;
                if (makeDirty && autoStashToggle.checked) {
                    clearTimeout(stashTimeout);
                    stashTimeout = setTimeout(() => {
                        stashInput(true); // true for auto-stash (silent)
                    }, STASH_DEBOUNCE_TIME);
                }
            }

            function stashInput(isAuto = false) {
                localStorage.setItem(STASH_KEY, inputText.value);
                markDirty(false); // Stashing counts as saving the current state
                
                if (!isAuto) {
                    const originalText = manualStashBtn.innerHTML;
                    manualStashBtn.innerHTML = '<i class="material-icons">check</i> Saved!';
                    setTimeout(() => {
                        manualStashBtn.innerHTML = '<i class="material-icons">save</i> Save Draft';
                    }, 1500);
                }
                console.log(isAuto ? "Auto-stashed." : "Manually stashed.");
            }

            function loadStashedInput() {
                const stashedText = localStorage.getItem(STASH_KEY);
                if (stashedText !== null) {
                    if (isDirty && !confirm("You have unsaved changes. Load draft and overwrite current input?")) {
                        return;
                    }
                    inputText.value = stashedText;
                    updateEditorVisuals();
                    runLinter();
                    markDirty(false);
                    const originalText = loadStashBtn.innerHTML;
                    loadStashBtn.innerHTML = '<i class="material-icons">done_all</i> Loaded!';
                    setTimeout(() => {
                        loadStashBtn.innerHTML = '<i class="material-icons">restore</i> Load Draft';
                    }, 1500);
                    console.log("Stashed input loaded.");
                } else {
                    const originalText = loadStashBtn.innerHTML;
                    loadStashBtn.innerHTML = '<i class="material-icons">info</i> No Draft!';
                    setTimeout(() => {
                        loadStashBtn.innerHTML = '<i class="material-icons">restore</i> Load Draft';
                    }, 1500);
                }
            }

            function clearStashedInput() {
                if (confirm("Are you sure you want to clear the saved draft from your browser? This cannot be undone.")) {
                    localStorage.removeItem(STASH_KEY);
                    console.log("Stash cleared.");
                    const originalText = clearStashBtn.innerHTML;
                    clearStashBtn.innerHTML = '<i class="material-icons">check</i> Cleared!';
                    setTimeout(() => {
                        clearStashBtn.innerHTML = '<i class="material-icons">delete_sweep</i>';
                    }, 1500);
                }
            }

            autoStashToggle.addEventListener('change', function() {
                localStorage.setItem(AUTO_STASH_ENABLED_KEY, this.checked);
                if (this.checked && inputText.value.trim() !== "") {
                    stashInput(true); // Stash immediately if enabling and there's content
                }
            });
            manualStashBtn.addEventListener('click', () => stashInput(false));
            loadStashBtn.addEventListener('click', loadStashedInput);
            clearStashBtn.addEventListener('click', clearStashedInput);

            // --- Initialize Stash State on Page Load ---
            function initializeAppSate() {
                const autoStashWasEnabled = localStorage.getItem(AUTO_STASH_ENABLED_KEY) === 'true';
                autoStashToggle.checked = autoStashWasEnabled;

                const stashedText = localStorage.getItem(STASH_KEY);
                let loadedFromStash = false;
                if (stashedText !== null) {
                    if (confirm("A saved draft was found. Load it?")) {
                        inputText.value = stashedText;
                        loadedFromStash = true;
                    }
                }

                if (loadedFromStash) {
                    updateEditorVisuals();
                    runLinter();
                    markDirty(false);
                } else {
                    loadTemplate('empty'); // Load default if no stash loaded
                }
            }

            initializeAppSate(); // Call initialization

            // --- `beforeunload` warning ---
            window.addEventListener('beforeunload', function (e) {
                if (isDirty) {
                    e.preventDefault(); // For modern browsers
                    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'; // For older browsers
                    return 'You have unsaved changes. Are you sure you want to leave?'; // For some other browsers
                }
            });

            // Function to load a template from a file
            async function loadTemplate(templateKey) {
                const currentActive = document.querySelector('.template-btn.active');
                // Check if the target template is different from the current one before asking for confirmation
                if (isDirty && (!currentActive || templateKey !== currentActive.dataset.template)) {
                    if (!confirm("You have unsaved changes that will be lost by loading a new template. Continue?")) {
                        // Revert active class if user cancels and a different button was clicked
                        const targetBtn = document.querySelector(`.template-btn[data-template="${templateKey}"]`);
                        if (targetBtn && currentActive && targetBtn !== currentActive) {
                            targetBtn.classList.remove('active');
                            currentActive.classList.add('active');
                        }
                        return Promise.reject("User cancelled template load due to unsaved changes.");
                    }
                }

                const filePath = templateFiles[templateKey];
                if (!filePath) {
                    console.error(`Template key "${templateKey}" not found in templateFiles mapping.`);
                    inputText.value = `Error: Template configuration for "${templateKey}" is missing.`;
                    updateEditorVisuals();
                    runLinter();
                    return;
                }
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} for ${filePath}`);
                    }
                    const text = await response.text();
                    inputText.value = text;
                    // Update active button after successful load
                    templateBtns.forEach(b => b.classList.remove('active'));
                    const newActiveBtn = document.querySelector(`.template-btn[data-template="${templateKey}"]`);
                    if (newActiveBtn) newActiveBtn.classList.add('active');

                } catch (error) {
                    console.error(`Error fetching template "${templateKey}":`, error);
                    inputText.value = `Error loading template: ${templateKey}\n\n${error.message}\n\nEnsure the file exists at '${filePath}' (relative to the HTML file) and that you are serving this page via an HTTP server (not directly from file:///), especially for local development.`;
                } finally {
                    inputText.scrollTop = 0;
                    updateEditorVisuals();
                    runLinter();
                    resetConvertButtonState();
                    markDirty(false); // Successfully loaded a template
                }
            }

            templateBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const previouslyActive = document.querySelector('.template-btn.active');
                    if (btn === previouslyActive) return;
                    loadTemplate(btn.dataset.template);
                });
            });

            convertBtn.addEventListener('click', handleConvertClick);
            
            function handleConvertClick() {
                clearTimeout(convertClickTimer);
                convertClickCount++;

                if (convertClickCount === 1) {
                    convertToPList();
                    convertBtn.innerHTML = '<i class="material-icons">arrow_downward</i> Scroll to Output?';
                    convertClickTimer = setTimeout(() => {
                        resetConvertButtonState();
                    }, DOUBLE_CLICK_TIMEOUT);
                } else if (convertClickCount === 2) {
                    if (outputText.value === '' || outputText.value === 'Your converted PList will appear here...') {
                        convertToPList();
                    }
                    outputCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    resetConvertButtonState();
                }
            }

            function resetConvertButtonState() {
                convertClickCount = 0;
                convertBtn.innerHTML = originalConvertBtnHTML;
                clearTimeout(convertClickTimer);
            }
            
            function copyToClipboardHandler() {
                outputText.select();
                document.execCommand('copy');
                const originalDesktopHTML = copyBtn.innerHTML;
                const originalMobileHTML = mobileCopyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="material-icons">check</i>';
                mobileCopyBtn.innerHTML = '<i class="material-icons">check</i> Copied!';
                setTimeout(() => {
                    copyBtn.innerHTML = originalDesktopHTML;
                    mobileCopyBtn.innerHTML = originalMobileHTML;
                }, 2000);
            }
            copyBtn.addEventListener('click', copyToClipboardHandler);
            mobileCopyBtn.addEventListener('click', copyToClipboardHandler);

            clearBtn.addEventListener('click', () => {
                if (inputText.value !== '' || outputText.value !== '') {
                    if (isDirty || inputText.value.trim() !== '') { // Check if dirty or if there's actual text
                         if (!confirm("Are you sure you want to clear the input and output? Unsaved changes will be lost.")) {
                            return;
                        }
                    }
                }
                inputText.value = '';
                outputText.value = '';
                updateEditorVisuals();
                runLinter();
                resetConvertButtonState();
                markDirty(false);
            });

            function convertToPList() {
                let input = inputText.value;
                if (removeCommentsCheckbox.checked) {
                    input = input.replace(/(\/\/|#).*$/gm, '');
                }
                let processedInput = input.trim();
                if (processedInput.startsWith('[')) {
                    processedInput = processedInput.substring(1);
                }
                if (processedInput.endsWith(']')) {
                    processedInput = processedInput.substring(0, processedInput.length - 1);
                }
                let lines = processedInput.split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');
                let result = lines.join(' ');
                result = result.replace(/\(\s*\)/g, '');
                result = result.replace(/\s+/g, ' ');
                result = result.replace(/([\w-]+)\s+\(/g, '$1(');
                result = result.replace(/\(\s+/g, '(');
                result = result.replace(/\s+\)/g, ')');
                result = result.replace(/\)\s+;/g, ');');
                result = result.replace(/\s+/g, ' ');
                result = `[${result}]`;
                outputText.value = result;
            }

            formatPListBtn.addEventListener('click', function() {
                if (isDirty && outputText.value.trim() !== "" && inputText.value.trim() !== outputText.value.trim()) {
                     if (!confirm("You have unsaved changes in the input area. Formatting the PList output into the input area will overwrite them. Continue?")) {
                        return;
                    }
                }
                formatPListToTemplist();
            });

            function formatPListToTemplist() {
                const pListStr = outputText.value.trim();

                if (!pListStr.startsWith('[') || !pListStr.endsWith(']')) {
                    alert("PList Output is not a valid PList string (must start with '[' and end with ']'). Cannot format.");
                    return;
                }
                if (pListStr === "[]" || pListStr === "[ ]") {
                    inputText.value = "[\n]";
                    updateEditorVisuals(); runLinter(); markDirty(false); resetConvertButtonState();
                    return;
                }
                let content = pListStr.substring(1, pListStr.length - 1).trim();
                if (!content) {
                    inputText.value = "[\n]";
                    updateEditorVisuals(); runLinter(); markDirty(false); resetConvertButtonState();
                    return;
                }

                let formattedResult = "[\n";
                const baseIndent = "  ";
                const traitIndent = "    ";
                let currentIndentLvl = 0;
                let buffer = "";
                let parenDepth = 0;

                for (let i = 0; i < content.length; i++) {
                    const char = content[i];
                    buffer += char;

                    if (char === '(') parenDepth++;
                    else if (char === ')') parenDepth--;
                    else if (parenDepth === 0) {
                        const effectiveIndent = currentIndentLvl === 0 ? baseIndent : traitIndent;
                        if (char === ':') {
                            formattedResult += effectiveIndent + buffer.trim() + "\n";
                            buffer = "";
                            currentIndentLvl = 1;
                        } else if (char === ',') {
                            formattedResult += effectiveIndent + buffer.trim() + "\n";
                            buffer = "";
                        } else if (char === ';') {
                            formattedResult += effectiveIndent + buffer.trim() + "\n";
                            buffer = "";
                            currentIndentLvl = 0;
                        }
                    }
                }
                if (buffer.trim()) {
                    const effectiveIndent = currentIndentLvl === 0 ? baseIndent : traitIndent;
                    let lastPart = buffer.trim();
                    if (lastPart.endsWith(',') || lastPart.endsWith(';')) {
                        lastPart = lastPart.slice(0, -1);
                    }
                    formattedResult += effectiveIndent + lastPart + "\n";
                }
                
                let tempLines = formattedResult.trim().split('\n');
                if (tempLines.length > 1 && tempLines[0].trim() === "[") { // Check if first line is just "["
                    let lastContentLineIndex = tempLines.length -1;
                    if (lastContentLineIndex > 0) { // Ensure there's a line after "["
                        let lastContentLine = tempLines[lastContentLineIndex].trim();
                        if (lastContentLine.endsWith(',') || lastContentLine.endsWith(';')) {
                            tempLines[lastContentLineIndex] = tempLines[lastContentLineIndex].trim().slice(0,-1);
                        }
                        formattedResult = tempLines.join('\n');
                    }
                }


                formattedResult += "\n]";
                formattedResult = formattedResult.replace(/\n\s*\n/g, '\n');

                inputText.value = formattedResult;
                updateEditorVisuals();
                runLinter();
                resetConvertButtonState();
                markDirty(false);
            }

            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && editorContainer.classList.contains('fullscreen')) {
                    toggleFullscreen();
                }
                if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                    event.preventDefault();
                    stashInput(false);
                }
            });

            function toggleFullscreen() {
                editorContainer.classList.toggle('fullscreen');
                document.body.classList.toggle('fullscreen-active');
                Array.from(mainContainer.children).forEach(child => {
                    if (child !== editorContainer.closest('.card')) {
                         if (editorContainer.classList.contains('fullscreen')) child.style.display = 'none';
                         else child.style.display = '';
                    }
                });
                fullscreenIcon.textContent = editorContainer.classList.contains('fullscreen') ? 'fullscreen_exit' : 'fullscreen';
                if (editorContainer.classList.contains('fullscreen')) inputText.focus();
                updateEditorVisuals();
            }

            function updateEditorVisuals() {
                const lines = inputText.value.split('\n').length;
                const currentScrollTop = lineNumbersDiv.scrollTop;
                lineNumbersDiv.innerHTML = '';
                for (let i = 1; i <= lines; i++) {
                    const div = document.createElement('div');
                    div.textContent = i;
                    lineNumbersDiv.appendChild(div);
                }
                if (!editorContainer.classList.contains('fullscreen')) {
                    lineNumbersDiv.style.height = inputText.clientHeight + 'px';
                } else {
                    lineNumbersDiv.style.height = '';
                }
                lineNumbersDiv.scrollTop = currentScrollTop;
            }

            inputText.addEventListener('scroll', () => {
                lineNumbersDiv.scrollTop = inputText.scrollTop;
                if (window.getComputedStyle(lineNumbersDiv).display === 'none' && inputText.style.backgroundImage !== 'none') {
                     inputText.style.backgroundPosition = `0 ${inputText.scrollTop * -1}px`;
                }
            });

            let editorUpdateTimeout;
            inputText.addEventListener('input', () => {
                markDirty();
                clearTimeout(editorUpdateTimeout);
                editorUpdateTimeout = setTimeout(() => {
                    updateEditorVisuals();
                    runLinter();
                }, 150);
                resetConvertButtonState();
            });
            
            new ResizeObserver(updateEditorVisuals).observe(inputText);

            function runLinter() {
                const text = inputText.value;
                const errors = [];
                const rawLines = text.split('\n');
                let openParenCount = 0;
                let openBracketCount = 0;
                const codeLines = [];
                rawLines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    codeLines.push({ text: trimmedLine, number: index + 1, original: line });
                    if (!trimmedLine.startsWith('//') && !trimmedLine.startsWith('#')) {
                        for (const char of trimmedLine) {
                            if (char === '(') openParenCount++;
                            else if (char === ')') openParenCount--;
                            else if (char === '[') openBracketCount++;
                            else if (char === ']') openBracketCount--;
                        }
                    }
                });
                const activeCodeLines = codeLines.filter(l => l.text !== '' && !l.text.startsWith('//') && !l.text.startsWith('#'));

                if (activeCodeLines.length > 0) {
                    if (!activeCodeLines[0].text.startsWith('[')) errors.push({ line: activeCodeLines[0].number, msg: "Missing opening '[' at the start.", type: 'error' });
                    const lastMeaningfulLine = [...activeCodeLines].reverse().find(l => l.text !== '');
                    if (lastMeaningfulLine && !lastMeaningfulLine.text.endsWith(']')) errors.push({ line: lastMeaningfulLine.number, msg: "Missing closing ']' at the end.", type: 'error' });
                } else if (text.trim() !== '' && text.trim() !== '[]' && text.trim() !== '[ ]') {
                    errors.push({ msg: "Content seems to be only comments or empty. Expected PList structure.", type: 'warning' });
                }
                if (openParenCount !== 0) errors.push({ msg: `Mismatched parentheses '(' and ')' globally (balance: ${openParenCount}).`, type: 'error' });
                if (openBracketCount !== 0) errors.push({ msg: `Mismatched brackets '[' and ']' globally (balance: ${openBracketCount}).`, type: 'error' });

                for (const lineObj of activeCodeLines) {
                    const line = lineObj.text;
                    let inSingleQuote = false, inDoubleQuote = false, inParen = 0, prevChar = '';
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === "'" && !inDoubleQuote && !inSingleQuote) inSingleQuote = true;
                        else if (char === "'" && inSingleQuote) inSingleQuote = false;
                        else if (char === '"' && !inSingleQuote && !inDoubleQuote) inDoubleQuote = true;
                        else if (char === '"' && inDoubleQuote) inDoubleQuote = false;
                        else if (char === '(' && !inSingleQuote && !inDoubleQuote) inParen++;
                        else if (char === ')' && !inSingleQuote && !inDoubleQuote && inParen > 0) inParen--;
                        if (inSingleQuote || inDoubleQuote || inParen > 0) { prevChar = ''; continue; }
                        if ('[];,:'.includes(char) && char === prevChar) errors.push({ line: lineObj.number, msg: `Duplicate symbol '${char}' detected.`, type: 'warning' });
                        prevChar = char;
                    }
                }
                let inCategory = false;
                for (let i = 0; i < activeCodeLines.length; i++) {
                    const lineObj = activeCodeLines[i];
                    const currentLine = lineObj.text;
                    const nextLineObj = (i + 1 < activeCodeLines.length) ? activeCodeLines[i+1] : null;
                    const nextLineText = nextLineObj ? nextLineObj.text : null;
                    if (i === 0 && currentLine.startsWith('[')) continue;
                    let isEffectivelyLastContentLine = (i === activeCodeLines.length - 1) || (i === activeCodeLines.length - 2 && nextLineText === ']');

                    if (currentLine.match(/^[\w\s-]+:\s*$/)) {
                        inCategory = true;
                        if (currentLine.slice(0, -1).trim() === "") errors.push({ line: lineObj.number, msg: "Category name appears empty.", type: 'warning' });
                    } else if (inCategory) {
                        let lineParenBalance = 0;
                        for (const char of currentLine) { if (char === '(') lineParenBalance++; else if (char === ')') lineParenBalance--; }
                        if (lineParenBalance !== 0 && openParenCount !== 0) errors.push({ line: lineObj.number, msg: "Mismatched parentheses on this line (contributes to global imbalance).", type: 'error' });
                        const isLastTraitOfThisCategoryBlock = nextLineText === null || nextLineText.match(/^[\w\s-]+:\s*$/) || (nextLineObj && nextLineObj.text === ']');
                        const lineWithoutComment = currentLine.replace(/(\/\/|#).*$/, '').trim();
                        if (isLastTraitOfThisCategoryBlock) {
                            if (isEffectivelyLastContentLine && lineWithoutComment.endsWith(';')) errors.push({ line: lineObj.number, msg: "Last category block should not end with ';'.", type: 'warning' });
                            else if (!isEffectivelyLastContentLine && nextLineText !== null && !lineWithoutComment.endsWith(';')) errors.push({ line: lineObj.number, msg: "End of category block? Might need a ';' before next category.", type: 'warning' });
                        } else {
                            if (lineWithoutComment.endsWith(';')) errors.push({ line: lineObj.number, msg: "Unexpected ';'. Semicolons usually end a category block, not individual traits.", type: 'warning' });
                            if (!lineWithoutComment.endsWith(',') && nextLineText && !nextLineText.match(/^[\w\s-]+:\s*$/) && nextLineText !== ']') errors.push({ line: lineObj.number, msg: "Missing ',' after this trait?", type: 'warning' });
                        }
                    } else if (currentLine !== '[' && currentLine !== ']') {
                        errors.push({ line: lineObj.number, msg: "Line outside a category. Expected 'Category Name:'.", type: 'warning' });
                    }
                }
                displayLintMessages(errors);
            }

            function displayLintMessages(errors) {
                lintMessagesUl.innerHTML = '';
                if (errors.length === 0) {
                    const li = document.createElement('li');
                    li.innerHTML = `<i class="material-icons lint-icon" style="color: #4CAF50;">check_circle</i> No obvious syntax issues found.`;
                    lintMessagesUl.appendChild(li);
                    return;
                }
                errors.forEach(err => {
                    const li = document.createElement('li');
                    const icon = err.type === 'error' ? 'error' : 'warning';
                    const iconColor = err.type === 'error' ? 'var(--md-error)' : 'var(--md-warning)';
                    li.innerHTML = `<i class="material-icons lint-icon" style="color:${iconColor};">${icon}</i> ${err.line ? `L${err.line}: ` : ''}${err.msg}`;
                    if (err.line) {
                        li.dataset.lineNumber = err.line;
                        li.addEventListener('click', () => { scrollToLine(err.line); highlightLine(err.line); });
                    }
                    lintMessagesUl.appendChild(li);
                });
            }

            function scrollToLine(lineNumber) {
                const lines = inputText.value.substring(0, inputText.value.length).split('\n');
                let charCount = 0;
                for (let i = 0; i < lineNumber - 1; i++) charCount += lines[i].length + 1;
                inputText.focus();
                inputText.setSelectionRange(charCount, charCount);
                const lineHeight = parseFloat(getComputedStyle(inputText).lineHeight);
                const paddingTop = parseFloat(getComputedStyle(inputText).paddingTop);
                const targetScrollTop = (lineNumber - 1) * lineHeight + paddingTop - (inputText.clientHeight / 3);
                inputText.scrollTop = Math.max(0, targetScrollTop);
            }

            let highlightTimeout;
            function highlightLine(lineNumber) {
                clearTimeout(highlightTimeout);
                if (window.getComputedStyle(lineNumbersDiv).display !== 'none') {
                    lineNumbersDiv.querySelectorAll('div.highlighted').forEach(el => el.classList.remove('highlighted'));
                    const targetLineDiv = lineNumbersDiv.children[lineNumber - 1];
                    if (targetLineDiv) {
                        targetLineDiv.classList.add('highlighted');
                        highlightTimeout = setTimeout(() => targetLineDiv.classList.remove('highlighted'), 1500);
                    }
                } else {
                    const lineHeight = parseFloat(getComputedStyle(inputText).lineHeight);
                    const paddingTop = parseFloat(getComputedStyle(inputText).paddingTop);
                    const highlightYPositionInTextarea = (lineNumber - 1) * lineHeight + paddingTop - inputText.scrollTop;
                    inputText.style.backgroundImage = `linear-gradient(transparent, transparent ${highlightYPositionInTextarea -1}px, var(--textarea-highlight-color) ${highlightYPositionInTextarea -1}px, var(--textarea-highlight-color) ${highlightYPositionInTextarea + lineHeight -1}px, transparent ${highlightYPositionInTextarea + lineHeight -1}px)`;
                    highlightTimeout = setTimeout(() => { inputText.style.backgroundImage = 'none'; }, 1500);
                }
            }

            window.onscroll = function() {scrollFunction()};
            function scrollFunction() {
                scrollToTopBtn.style.display = (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) ? "flex" : "none";
            }
            scrollToTopBtn.addEventListener('click', () => window.scrollTo({top: 0, behavior: 'smooth'}));
        });
    </script>
</body>
</html>
